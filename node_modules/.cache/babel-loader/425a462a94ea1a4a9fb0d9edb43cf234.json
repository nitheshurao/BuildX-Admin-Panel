{"ast":null,"code":"/** Franklin M. Liang's hyphenation algorithm, implemented in Javascript.\n *  Copyright (C) 2016 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the MIT license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  var // settings\n  SETTING_ASYNC_MODE = false,\n      SETTING_DEBUG = false,\n      SETTING_HYPHEN_CHAR = \"\\xAD\";\n\n  function hyphenateWord(text, patterns, debug, hyphenChar) {\n    var levels = new Array(text.length + 1),\n        loweredText = text.toLocaleLowerCase(),\n        p = [],\n        pattern,\n        patternData,\n        patternIndex = 0;\n\n    for (var i = levels.length; i--;) {\n      levels[i] = 0;\n    }\n\n    while (patternData = patterns[patternIndex++]) {\n      var fromChar = 0;\n      var endPattern = false;\n\n      while (!endPattern) {\n        var patternEntityIndex = loweredText.indexOf(patternData.text, fromChar);\n        var patternFits = patternEntityIndex > -1 && (patternData.stickToLeft ? patternEntityIndex === 0 : true) && (patternData.stickToRight ? patternEntityIndex + patternData.text.length === text.length : true);\n\n        if (patternFits) {\n          p.push(patternData.pattern + \">\" + patternData.levels.join(\"\"));\n\n          for (var i = 0; i < patternData.levels.length; i++) {\n            levels[patternEntityIndex + i] = Math.max(patternData.levels[i], levels[patternEntityIndex + i]);\n          }\n        }\n\n        if (patternEntityIndex > -1 && patternData.text.length > 0) {\n          fromChar = patternEntityIndex + patternData.text.length + 1;\n        } else {\n          endPattern = true;\n        }\n      }\n    }\n\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;\n    var hyphenatedText = \"\",\n        leveledText = \"\",\n        debugHyphenatedText = \"\";\n\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText += (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n      debugHyphenatedText += (levels[i] % 2 === 1 ? \"-\" : \"\") + text.charAt(i);\n      leveledText += (levels[i] > 0 ? levels[i] : \"\") + text.charAt(i);\n    }\n\n    if (debug) console.log.apply(console, [text, \"->\"].concat(p).concat([\"->\"]).concat(levels).concat([\"->\", leveledText]).concat([\"->\", debugHyphenatedText]));\n    return hyphenatedText;\n  }\n\n  function createTextChunkReader(text, hyphenChar) {\n    function readNextTextChunk() {\n      var nextTextChunk = \"\";\n      shouldHyphenate = void 0;\n\n      chunkReader: while (nextCharIndex <= text.length) {\n        var nextChar = text.charAt(nextCharIndex++),\n            charIsLetter = !!nextChar && !/\\s|[\\!-\\@\\[-\\`\\{-\\~\\u2013-\\u203C]/.test(nextChar),\n            charIsAngleOpen = nextChar === \"<\",\n            charIsAngleClose = nextChar === \">\",\n            charIsHyphen = nextChar === hyphenChar;\n\n        do {\n          if (state === STATE_READ_TAG) {\n            if (charIsAngleClose) {\n              state = STATE_RETURN_TAG;\n            }\n\n            break;\n          }\n\n          if (charIsHyphen) {\n            shouldHyphenate = SHOULD_SKIP;\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (charIsLetter) {\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (state === STATE_READ_WORD) {\n            state = STATE_RETURN_WORD;\n            shouldHyphenate = shouldHyphenate || nextTextChunk.length > 4 && SHOULD_HYPHENATE;\n            break;\n          }\n\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_RETURN_CHAR;\n        } while (0);\n\n        if (charIsAngleOpen && state !== STATE_RETURN_WORD) {\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_READ_TAG;\n        }\n\n        switch (state) {\n          case STATE_READ_TAG:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_READ_WORD:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_RETURN_CHAR:\n            nextTextChunk = nextChar;\n            break chunkReader;\n\n          case STATE_RETURN_TAG:\n            nextTextChunk += nextChar;\n            break chunkReader;\n\n          case STATE_RETURN_WORD:\n            nextCharIndex--;\n            break chunkReader;\n        }\n      }\n\n      return nextTextChunk || void 0;\n    }\n\n    function shouldNextHyphenate() {\n      return shouldHyphenate === SHOULD_HYPHENATE;\n    }\n\n    var nextCharIndex = 0,\n        SHOULD_HYPHENATE = 1,\n        SHOULD_SKIP = 2,\n        shouldHyphenate,\n        STATE_READ_TAG = 1,\n        STATE_READ_WORD = 2,\n        STATE_RETURN_CHAR = 3,\n        STATE_RETURN_TAG = 4,\n        STATE_RETURN_WORD = 5,\n        state;\n    return [readNextTextChunk, shouldNextHyphenate];\n  }\n\n  function start(text, patterns, cache, debug, hyphenChar, isAsync) {\n    function done() {\n      allTime = new Date() - allTime;\n      resolveNewText(newText);\n\n      if (debug) {\n        console.log(\"----------------\\nHyphenation stats: \" + processedN + \" words processed, \" + hyphenatedN + \" words hyphenated\");\n        console.log(\"Work time: \".concat(workTime / 1000));\n        console.log(\"Wait time: \".concat((allTime - workTime) / 1000));\n        console.log(\"All time: \".concat(allTime / 1000));\n      }\n    }\n\n    var newText = \"\",\n        nextTextChunk,\n        reader = createTextChunkReader(text, hyphenChar),\n        readNextTextChunk = reader[0],\n        shouldNextHyphenate = reader[1],\n        states = {\n      hyphenateWord: 1,\n      concatenate: 2\n    },\n        processedN = 0,\n        hyphenatedN = 0;\n    var allTime = new Date(),\n        workTime = 0;\n\n    var resolveNewText = function resolveNewText() {};\n\n    (function nextTick() {\n      var loopStart = new Date();\n\n      while ((!isAsync || new Date() - loopStart < 10) && (nextTextChunk = readNextTextChunk())) {\n        var state = shouldNextHyphenate() ? states.hyphenateWord : states.concatenate;\n\n        switch (state) {\n          case states.hyphenateWord:\n            if (!cache[nextTextChunk]) cache[nextTextChunk] = hyphenateWord(nextTextChunk, patterns, debug, hyphenChar);\n            if (nextTextChunk !== cache[nextTextChunk]) hyphenatedN++;\n            nextTextChunk = cache[nextTextChunk];\n\n          case states.concatenate:\n            newText += nextTextChunk;\n        }\n\n        processedN++;\n      }\n\n      workTime += new Date() - loopStart;\n\n      if (!nextTextChunk) {\n        done();\n      } else {\n        setTimeout(nextTick);\n      }\n    })();\n\n    if (isAsync) {\n      return new Promise(function (resolve) {\n        resolveNewText = resolve;\n      });\n    } else {\n      return newText;\n    }\n  } // extract useful data from pattern\n\n\n  function preprocessPattern(pattern) {\n    var patternCharIndex = 0,\n        patternChar,\n        patternData = {\n      pattern: pattern,\n      text: \"\",\n      levels: [],\n      stickToLeft: 0,\n      stickToRight: 0\n    },\n        states = {\n      alphabet: 1,\n      level: 2,\n      stickToLeft: 3,\n      stickToRight: 4\n    };\n\n    while (patternChar = pattern.charAt(patternCharIndex++)) {\n      var charIsDot = patternChar === \".\",\n          charIsNumber = !charIsDot && /\\d/.test(patternChar),\n          state = charIsDot ? patternCharIndex - 1 === 0 ? states.stickToLeft : states.stickToRight : charIsNumber ? states.level : states.alphabet;\n\n      switch (state) {\n        case states.alphabet:\n          !prevCharIsNumber && patternData.levels.push(0);\n          patternData.text += patternChar;\n          break;\n\n        case states.level:\n          patternData.levels.push(parseInt(patternChar));\n          break;\n\n        case states.stickToLeft:\n          patternData.stickToLeft = true;\n          break;\n\n        case states.stickToRight:\n          patternData.stickToRight = true;\n          break;\n      }\n\n      var prevCharIsNumber = charIsNumber;\n    }\n\n    return patternData;\n  }\n\n  function purifyPatterns(text) {\n    return text // Remove comments\n    .replace(/%.*/g, \"\") // Remove repeating spaces\n    .replace(/\\s+/g, \" \") // Trim spaces\n    .replace(/^\\s|\\s$/g, \"\") // Split to Array\n    .split(\" \");\n  } // Hyphenator factory\n\n\n  return function (patternsDefinition, settings) {\n    var // Settings\n    debug = settings && settings.debug !== undefined && settings.debug || SETTING_DEBUG,\n        hyphenChar = settings && settings.hyphenChar !== undefined && settings.hyphenChar || SETTING_HYPHEN_CHAR,\n        asyncMode = settings && settings.async !== undefined && settings.async || SETTING_ASYNC_MODE,\n        cache = {},\n        // Preprocess patterns\n    patterns = (patternsDefinition.patterns.splice ? patternsDefinition.patterns : purifyPatterns(patternsDefinition.patterns)).map(function (pattern) {\n      return preprocessPattern(pattern);\n    }); // Prepare cache\n\n    (patternsDefinition.exceptions.splice ? patternsDefinition.exceptions : purifyPatterns(patternsDefinition.exceptions)).forEach(function (exception) {\n      cache[exception.replace(/\\-/g, \"\")] = exception.replace(/\\-/g, hyphenChar);\n    }); // Hyphenator function\n\n    return function (text) {\n      return start(text, patterns, cache, debug, hyphenChar, asyncMode);\n    };\n  };\n});","map":{"version":3,"sources":["/Users/redhan/Desktop/work/Ecom-Admin/node_modules/hyphen/hyphen.js"],"names":["root","factory","define","amd","module","exports","createHyphenator","SETTING_ASYNC_MODE","SETTING_DEBUG","SETTING_HYPHEN_CHAR","hyphenateWord","text","patterns","debug","hyphenChar","levels","Array","length","loweredText","toLocaleLowerCase","p","pattern","patternData","patternIndex","i","fromChar","endPattern","patternEntityIndex","indexOf","patternFits","stickToLeft","stickToRight","push","join","Math","max","hyphenatedText","leveledText","debugHyphenatedText","charAt","console","log","apply","concat","createTextChunkReader","readNextTextChunk","nextTextChunk","shouldHyphenate","chunkReader","nextCharIndex","nextChar","charIsLetter","test","charIsAngleOpen","charIsAngleClose","charIsHyphen","state","STATE_READ_TAG","STATE_RETURN_TAG","SHOULD_SKIP","STATE_READ_WORD","STATE_RETURN_WORD","SHOULD_HYPHENATE","STATE_RETURN_CHAR","shouldNextHyphenate","start","cache","isAsync","done","allTime","Date","resolveNewText","newText","processedN","hyphenatedN","workTime","reader","states","concatenate","nextTick","loopStart","setTimeout","Promise","resolve","preprocessPattern","patternCharIndex","patternChar","alphabet","level","charIsDot","charIsNumber","prevCharIsNumber","parseInt","purifyPatterns","replace","split","patternsDefinition","settings","undefined","asyncMode","async","splice","map","exceptions","forEach","exception"],"mappings":"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","sourcesContent":["/** Franklin M. Liang's hyphenation algorithm, implemented in Javascript.\n *  Copyright (C) 2016 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the MIT license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function() {\n  var // settings\n    SETTING_ASYNC_MODE = false,\n    SETTING_DEBUG = false,\n    SETTING_HYPHEN_CHAR = \"\\u00AD\";\n\n  function hyphenateWord(text, patterns, debug, hyphenChar) {\n    var levels = new Array(text.length + 1),\n      loweredText = text.toLocaleLowerCase(),\n      p = [],\n      pattern,\n      patternData,\n      patternIndex = 0;\n\n    for (var i = levels.length; i--; ) levels[i] = 0;\n\n    while ((patternData = patterns[patternIndex++])) {\n      var fromChar = 0;\n      var endPattern = false;\n      while (!endPattern) {\n        var patternEntityIndex = loweredText.indexOf(\n          patternData.text,\n          fromChar\n        );\n\n        var patternFits =\n          patternEntityIndex > -1 &&\n          (patternData.stickToLeft ? patternEntityIndex === 0 : true) &&\n          (patternData.stickToRight\n            ? patternEntityIndex + patternData.text.length === text.length\n            : true);\n\n        if (patternFits) {\n          p.push(patternData.pattern + \">\" + patternData.levels.join(\"\"));\n\n          for (var i = 0; i < patternData.levels.length; i++)\n            levels[patternEntityIndex + i] = Math.max(\n              patternData.levels[i],\n              levels[patternEntityIndex + i]\n            );\n        }\n        if (patternEntityIndex > -1 && patternData.text.length > 0) {\n          fromChar = patternEntityIndex + patternData.text.length + 1;\n        } else {\n          endPattern = true;\n        }\n      }\n    }\n\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[\n      levels.length - 2\n    ] = 0;\n\n    var hyphenatedText = \"\",\n      leveledText = \"\",\n      debugHyphenatedText = \"\";\n\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText +=\n        (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n      debugHyphenatedText += (levels[i] % 2 === 1 ? \"-\" : \"\") + text.charAt(i);\n      leveledText += (levels[i] > 0 ? levels[i] : \"\") + text.charAt(i);\n    }\n\n    if (debug)\n      console.log.apply(\n        console,\n        [text, \"->\"]\n          .concat(p)\n          .concat([\"->\"])\n          .concat(levels)\n          .concat([\"->\", leveledText])\n          .concat([\"->\", debugHyphenatedText])\n      );\n\n    return hyphenatedText;\n  }\n\n  function createTextChunkReader(text, hyphenChar) {\n    function readNextTextChunk() {\n      var nextTextChunk = \"\";\n\n      shouldHyphenate = void 0;\n\n      chunkReader: while (nextCharIndex <= text.length) {\n        var nextChar = text.charAt(nextCharIndex++),\n          charIsLetter =\n            !!nextChar && !/\\s|[\\!-\\@\\[-\\`\\{-\\~\\u2013-\\u203C]/.test(nextChar),\n          charIsAngleOpen = nextChar === \"<\",\n          charIsAngleClose = nextChar === \">\",\n          charIsHyphen = nextChar === hyphenChar;\n\n        do {\n          if (state === STATE_READ_TAG) {\n            if (charIsAngleClose) {\n              state = STATE_RETURN_TAG;\n            }\n            break;\n          }\n\n          if (charIsHyphen) {\n            shouldHyphenate = SHOULD_SKIP;\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (charIsLetter) {\n            state = STATE_READ_WORD;\n            break;\n          }\n\n          if (state === STATE_READ_WORD) {\n            state = STATE_RETURN_WORD;\n            shouldHyphenate =\n              shouldHyphenate || (nextTextChunk.length > 4 && SHOULD_HYPHENATE);\n            break;\n          }\n\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_RETURN_CHAR;\n        } while (0);\n\n        if (charIsAngleOpen && state !== STATE_RETURN_WORD) {\n          shouldHyphenate = SHOULD_SKIP;\n          state = STATE_READ_TAG;\n        }\n\n        switch (state) {\n          case STATE_READ_TAG:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_READ_WORD:\n            nextTextChunk += nextChar;\n            break;\n\n          case STATE_RETURN_CHAR:\n            nextTextChunk = nextChar;\n            break chunkReader;\n\n          case STATE_RETURN_TAG:\n            nextTextChunk += nextChar;\n            break chunkReader;\n\n          case STATE_RETURN_WORD:\n            nextCharIndex--;\n            break chunkReader;\n        }\n      }\n      return nextTextChunk || void 0;\n    }\n\n    function shouldNextHyphenate() {\n      return shouldHyphenate === SHOULD_HYPHENATE;\n    }\n\n    var nextCharIndex = 0,\n      SHOULD_HYPHENATE = 1,\n      SHOULD_SKIP = 2,\n      shouldHyphenate,\n      STATE_READ_TAG = 1,\n      STATE_READ_WORD = 2,\n      STATE_RETURN_CHAR = 3,\n      STATE_RETURN_TAG = 4,\n      STATE_RETURN_WORD = 5,\n      state;\n\n    return [readNextTextChunk, shouldNextHyphenate];\n  }\n\n  function start(text, patterns, cache, debug, hyphenChar, isAsync) {\n    function done() {\n      allTime = new Date() - allTime;\n      resolveNewText(newText);\n\n      if (debug) {\n        console.log(\n          \"----------------\\nHyphenation stats: \" +\n            processedN +\n            \" words processed, \" +\n            hyphenatedN +\n            \" words hyphenated\"\n        );\n        console.log(`Work time: ${workTime / 1000}`);\n        console.log(`Wait time: ${(allTime - workTime) / 1000}`);\n        console.log(`All time: ${allTime / 1000}`);\n      }\n    }\n\n    var newText = \"\",\n      nextTextChunk,\n      reader = createTextChunkReader(text, hyphenChar),\n      readNextTextChunk = reader[0],\n      shouldNextHyphenate = reader[1],\n      states = { hyphenateWord: 1, concatenate: 2 },\n      processedN = 0,\n      hyphenatedN = 0;\n\n    var allTime = new Date(),\n      workTime = 0;\n\n    var resolveNewText = function() {};\n\n    (function nextTick() {\n      var loopStart = new Date();\n\n      while (\n        (!isAsync || new Date() - loopStart < 10) &&\n        (nextTextChunk = readNextTextChunk())\n      ) {\n        var state = shouldNextHyphenate()\n          ? states.hyphenateWord\n          : states.concatenate;\n\n        switch (state) {\n          case states.hyphenateWord:\n            if (!cache[nextTextChunk])\n              cache[nextTextChunk] = hyphenateWord(\n                nextTextChunk,\n                patterns,\n                debug,\n                hyphenChar\n              );\n\n            if (nextTextChunk !== cache[nextTextChunk]) hyphenatedN++;\n\n            nextTextChunk = cache[nextTextChunk];\n\n          case states.concatenate:\n            newText += nextTextChunk;\n        }\n\n        processedN++;\n      }\n      workTime += new Date() - loopStart;\n\n      if (!nextTextChunk) {\n        done();\n      } else {\n        setTimeout(nextTick);\n      }\n    })();\n\n    if (isAsync) {\n      return new Promise(function(resolve) {\n        resolveNewText = resolve;\n      });\n    } else {\n      return newText;\n    }\n  }\n\n  // extract useful data from pattern\n  function preprocessPattern(pattern) {\n    var patternCharIndex = 0,\n      patternChar,\n      patternData = {\n        pattern: pattern,\n        text: \"\",\n        levels: [],\n        stickToLeft: 0,\n        stickToRight: 0\n      },\n      states = { alphabet: 1, level: 2, stickToLeft: 3, stickToRight: 4 };\n\n    while ((patternChar = pattern.charAt(patternCharIndex++))) {\n      var charIsDot = patternChar === \".\",\n        charIsNumber = !charIsDot && /\\d/.test(patternChar),\n        state = charIsDot\n          ? patternCharIndex - 1 === 0\n            ? states.stickToLeft\n            : states.stickToRight\n          : charIsNumber\n          ? states.level\n          : states.alphabet;\n\n      switch (state) {\n        case states.alphabet:\n          !prevCharIsNumber && patternData.levels.push(0);\n          patternData.text += patternChar;\n          break;\n\n        case states.level:\n          patternData.levels.push(parseInt(patternChar));\n          break;\n\n        case states.stickToLeft:\n          patternData.stickToLeft = true;\n          break;\n\n        case states.stickToRight:\n          patternData.stickToRight = true;\n          break;\n      }\n\n      var prevCharIsNumber = charIsNumber;\n    }\n\n    return patternData;\n  }\n\n  function purifyPatterns(text) {\n    return (\n      text\n        // Remove comments\n        .replace(/%.*/g, \"\")\n        // Remove repeating spaces\n        .replace(/\\s+/g, \" \")\n        // Trim spaces\n        .replace(/^\\s|\\s$/g, \"\")\n        // Split to Array\n        .split(\" \")\n    );\n  }\n\n  // Hyphenator factory\n  return function(patternsDefinition, settings) {\n    var // Settings\n      debug =\n        (settings && settings.debug !== undefined && settings.debug) ||\n        SETTING_DEBUG,\n      hyphenChar =\n        (settings &&\n          settings.hyphenChar !== undefined &&\n          settings.hyphenChar) ||\n        SETTING_HYPHEN_CHAR,\n      asyncMode =\n        (settings && settings.async !== undefined && settings.async) ||\n        SETTING_ASYNC_MODE,\n      cache = {},\n      // Preprocess patterns\n      patterns = (patternsDefinition.patterns.splice\n        ? patternsDefinition.patterns\n        : purifyPatterns(patternsDefinition.patterns)\n      ).map(function(pattern) {\n        return preprocessPattern(pattern);\n      });\n    // Prepare cache\n    (patternsDefinition.exceptions.splice\n      ? patternsDefinition.exceptions\n      : purifyPatterns(patternsDefinition.exceptions)\n    ).forEach(function(exception) {\n      cache[exception.replace(/\\-/g, \"\")] = exception.replace(\n        /\\-/g,\n        hyphenChar\n      );\n    });\n\n    // Hyphenator function\n    return function(text) {\n      return start(text, patterns, cache, debug, hyphenChar, asyncMode);\n    };\n  };\n});\n"]},"metadata":{},"sourceType":"script"}